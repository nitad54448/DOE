<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>General Purpose DOE Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); padding: 1.5rem; }
        input[type="number"] { -moz-appearance: textfield; appearance: none; }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .alert-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); align-items: center; justify-content: center; }
        .alert-modal-content { background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 400px; border-radius: 0.5rem; text-align: center; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2); }
        .alert-modal-close { background-color: #4f46e5; color: white; padding: 10px 20px; border: none; border-radius: 0.25rem; cursor: pointer; margin-top: 1rem; }
        .font-value { font-family: 'Courier New', Courier, monospace; }
        .factor-grid { display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 1rem; align-items: center; margin-bottom: 0.5rem; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto space-y-8">
        <header class="text-center">
            <h1 class="text-4xl font-bold text-slate-800">General Purpose Experiment Designer</h1>
            <p class="text-lg text-slate-600 mt-2">Design your experiment, enter results, find optima, and visualize response surfaces.</p>
        </header>

        <div id="main-content" class="space-y-8">
            <div id="design-section" class="card space-y-8">
                <div>
                    <h2 class="text-2xl font-semibold text-slate-700 mb-4">1. Define Factors</h2>
                    <div id="factor-inputs" class="space-y-4">
                        <div class="factor-grid font-medium text-slate-600 text-sm">
                            <span>Factor (Unit)</span>
                            <span>Min</span>
                            <span>Max</span>
                        </div>
                    </div>
                </div>

                <div class="border-t pt-6">
                    <h2 class="text-2xl font-semibold text-slate-700 mb-4">2. Define Responses</h2>
                    <div class="mb-4">
                        <label for="num-responses" class="block text-sm font-medium text-slate-700">Number of Responses (1-3)</label>
                        <input type="number" id="num-responses" value="3" min="1" max="3" class="mt-1 bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2.5 w-24">
                    </div>
                    <div id="response-inputs" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <!-- Response name inputs will be generated by JS here -->
                    </div>
                </div>
                
                <div class="border-t pt-6">
                    <h2 class="text-2xl font-semibold text-slate-700 mb-4">3. Generate Plan</h2>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 items-end">
                        <div>
                            <label for="design-type" class="block text-sm font-medium text-slate-700 mb-1">Type of Design</label>
                            <select id="design-type" class="bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2.5 w-full">
                                <optgroup label="Screening Designs">
                                    <option value="factorial">Full Factorial</option>
                                    <option value="fractional-factorial">Fractional Factorial</option>
                                    <option value="taguchi">Taguchi (L8)</option>
                                </optgroup>
                                <optgroup label="Optimization Designs">
                                    <option value="box-behnken">Box-Behnken</option>
                                    <option value="central-composite" selected>Central Composite</option>
                                </optgroup>
                            </select>
                        </div>
                         <div id="design-options-container" class="space-y-1">
                            <div id="ccd-type-container">
                                <label for="ccd-type" class="block text-sm font-medium text-slate-700 mb-1">CCD Type (alpha)</label>
                                <select id="ccd-type" class="bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2.5 w-full">
                                    <option value="face-centered">Face-Centered (alpha = 1.0)</option>
                                    <option value="rotatable">Rotatable (alpha calculated)</option>
                                </select>
                            </div>
                            <div id="ff-note-container" class="hidden">
                                <p class="text-xs text-slate-500">Generates a Resolution III or IV design based on the number of factors to screen for main effects efficiently.</p>
                            </div>
                         </div>
                        <button id="generate-plan-btn" class="w-full md:w-auto bg-indigo-600 text-white py-2.5 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 flex items-center justify-center">
                            Generate Plan & Proceed
                        </button>
                    </div>
                </div>
            </div>

            <div id="results-section" class="hidden space-y-8">
                <div class="card">
                     <h2 class="text-2xl font-semibold text-slate-700 mb-4">Response Analysis & Weighting</h2>
                    <div id="optimality-sliders" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                    </div>
                    <div id="optimum-results" class="grid grid-cols-1 md:grid-cols-4 gap-4 text-center">
                    </div>
                </div>

                <div class="card overflow-x-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-semibold text-slate-700">Experiment Data</h2>
                        <button id="fill-test-data-btn" class="bg-slate-200 text-slate-700 py-1 px-3 border border-transparent rounded-md shadow-sm text-xs font-medium hover:bg-slate-300 focus:outline-none">Fill with Test Data</button>
                    </div>
                    <table id="experiments-table" class="w-full text-sm text-left text-slate-500"><thead class="text-xs text-slate-700 uppercase bg-slate-50"></thead><tbody></tbody></table>
                </div>

                <div id="predicted-optima-card" class="card hidden">
                    <div class="flex justify-between items-start mb-4">
                        <h2 class="text-2xl font-semibold text-slate-700">Predicted Optimum Conditions</h2>
                         <div class="flex space-x-4">
                            <div>
                                <label for="rw-precision" class="block text-sm font-medium text-slate-700 mb-1">Search Precision</label>
                                <select id="rw-precision" class="bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2.5">
                                    <option value="coarse">Coarse (~1k steps)</option>
                                    <option value="fine" selected>Fine (~10k steps)</option>
                                    <option value="extensive">Extensive (~100k steps)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                     <div id="predicted-optima-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                     </div>
                    <div id="predicted-combined-display" class="hidden md:col-span-3 p-4 bg-purple-50 border border-purple-200 rounded-lg"></div>
                </div>

                <div id="statistics-container" class="hidden space-y-6"></div>

                <div id="plots-card" class="card hidden">
                    <h2 class="text-2xl font-semibold text-slate-700 mb-4">2D Contour Plots</h2>
                    <p id="contour-plots-placeholder" class="text-sm text-slate-600 mb-4">Enter enough results for your chosen design to generate models and plots.</p>
                    <div id="contour-plots-container" class="space-y-12"></div>
                </div>

                <div id="save-pdf-card" class="card hidden">
                     <h2 class="text-2xl font-semibold text-slate-700 mb-4">Export Report</h2>
                     <p class="text-sm text-slate-600 mb-4">Save a summary of the measured data, predicted optima, and model statistics as a PDF file for your records.</p>
                     <button id="save-pdf-btn" class="w-full md:w-auto bg-indigo-600 text-white py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium hover:bg-indigo-700">
                        Save Summary as PDF
                    </button>
                </div>
            </div>
        </div>

        <footer class="max-w-7xl mx-auto mt-12 py-4 border-t text-xs text-slate-500 flex justify-between items-center">
            <div id="footer-left"></div>
            <div id="footer-right">NitaD, Univ Paris-Saclay</div>
        </footer>
    </div>

    <div id="alert-modal" class="alert-modal"><div class="alert-modal-content"><p id="alert-message"></p><button id="alert-close" class="alert-modal-close">OK</button></div></div>

    <script>
        // --- DOM Elements ---
        const designSection = document.getElementById('design-section');
        const factorInputsContainer = document.getElementById('factor-inputs');
        const generatePlanBtn = document.getElementById('generate-plan-btn');
        const designTypeEl = document.getElementById('design-type');
        const ccdTypeContainer = document.getElementById('ccd-type-container');
        const ffNoteContainer = document.getElementById('ff-note-container');
        const ccdTypeEl = document.getElementById('ccd-type');
        const numResponsesEl = document.getElementById('num-responses');
        const responseInputsContainer = document.getElementById('response-inputs');
        const resultsSection = document.getElementById('results-section');
        const tableHead = document.querySelector('#experiments-table thead');
        const tableBody = document.querySelector('#experiments-table tbody');
        const fillTestDataBtn = document.getElementById('fill-test-data-btn');
        const optimalitySlidersContainer = document.getElementById('optimality-sliders');
        const optimumResultsContainer = document.getElementById('optimum-results');
        const predictedOptimaCard = document.getElementById('predicted-optima-card');
        const predictedOptimaContainer = document.getElementById('predicted-optima-container');
        const predictedCombinedDisplay = document.getElementById('predicted-combined-display');
        const alertModal = document.getElementById('alert-modal');
        const alertMessage = document.getElementById('alert-message');
        const alertClose = document.getElementById('alert-close');
        const plotsCard = document.getElementById('plots-card');
        const statisticsContainer = document.getElementById('statistics-container');
        const contourPlotsContainer = document.getElementById('contour-plots-container');
        const contourPlotsPlaceholder = document.getElementById('contour-plots-placeholder');
        const savePdfCard = document.getElementById('save-pdf-card');
        const savePdfBtn = document.getElementById('save-pdf-btn');
        const rwPrecisionEl = document.getElementById('rw-precision');
        const footerLeft = document.getElementById('footer-left');
        const footerRight = document.getElementById('footer-right');

        // --- Global State ---
        let experimentData = [], definedFactors = [], responses = [];
        let currentDesignType = '';
        const MAX_RESPONSES = 3;

        // --- Initial Setup ---
        function setupFactorInputs() {
            const defaultFactors = [
                { id: 'param1', name: 'Param 1 (unit)', min: 0, max: 100 },
                { id: 'param2', name: 'Param 2 (unit)', min: 0, max: 100 },
                { id: 'param3', name: 'Param 3 (unit)', min: 0, max: 100 },
                { id: 'param4', name: 'Param 4 (unit)', min: 0, max: 0 },
                { id: 'param5', name: 'Param 5 (unit)', min: 0, max: 0 },
                { id: 'param6', name: 'Param 6 (unit)', min: 0, max: 0 }
            ];
            defaultFactors.forEach(factor => {
                const div = document.createElement('div');
                div.className = 'factor-grid data-row';
                div.dataset.id = factor.id;
                div.innerHTML = `<input type="text" value="${factor.name}" data-prop="name" class="bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2.5"><input type="number" value="${factor.min}" data-prop="min" min="0" step="any" class="bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2.5"><input type="number" value="${factor.max}" data-prop="max" min="0" step="any" class="bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2.5">`;
                factorInputsContainer.appendChild(div)
            });
            const today = new Date();
            const dateString = today.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
            footerLeft.textContent = `DOE_General_v1.2.html, ${dateString}`;
        }
        
        function setupResponseInputs() {
            responseInputsContainer.innerHTML = '';
            const numResponses = parseInt(numResponsesEl.value);
            for (let i = 1; i <= MAX_RESPONSES; i++) {
                const isVisible = i <= numResponses;
                const div = document.createElement('div');
                div.id = `response-input-wrapper-${i}`;
                div.style.display = isVisible ? 'block' : 'none';
                div.innerHTML = `<label for="response-name-${i}" class="block text-sm font-medium text-slate-700">Response ${i} Name</label><input type="text" id="response-name-${i}" value="Response ${i}" class="mt-1 bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2.5 w-full">`;
                responseInputsContainer.appendChild(div);
            }
        }

        // --- Event Listeners ---
        designTypeEl.addEventListener('change', handleDesignTypeChange);
        generatePlanBtn.addEventListener('click', generateAndInitialize);
        fillTestDataBtn.addEventListener('click', fillWithTestData);
        numResponsesEl.addEventListener('input', setupResponseInputs);
        tableBody.addEventListener('input', handleTableInputChange);
        alertClose.addEventListener('click', () => alertModal.style.display = 'none');
        savePdfBtn.addEventListener('click', saveAsPDF);
        rwPrecisionEl.addEventListener('change', analyzeData);
        optimalitySlidersContainer.addEventListener('input', handleSliderChange);

        // --- UI Functions ---
        function handleDesignTypeChange() {
            const selected = designTypeEl.value;
            ccdTypeContainer.classList.toggle('hidden', selected !== 'central-composite');
            ffNoteContainer.classList.toggle('hidden', selected !== 'fractional-factorial');
        }

        function customAlert(message) {
            alertMessage.textContent = message;
            alertModal.style.display = 'flex';
        }

        // --- Data Handling and Generation ---
        function getFactorsFromUI() {
            const factors = [];
            document.querySelectorAll('#factor-inputs .data-row').forEach(row => {
                const name = row.querySelector('[data-prop="name"]').value.trim();
                const min = parseFloat(row.querySelector('[data-prop="min"]').value);
                const max = parseFloat(row.querySelector('[data-prop="max"]').value);
                if(min < 0 || max < 0) { customAlert(`Factor "${name}" cannot have negative values.`); return; }
                if (name && !isNaN(min) && !isNaN(max)) { factors.push({ name, min, max, isVarying: min !== max }); }
            });
            return factors.filter(f => f.isVarying);
        }

        function getResponsesFromUI() {
            const definedResponses = [];
            const num = parseInt(numResponsesEl.value);
            for (let i = 1; i <= num; i++) {
                const nameInput = document.getElementById(`response-name-${i}`);
                if (nameInput && nameInput.value.trim()) { definedResponses.push({ id: `response${i}`, name: nameInput.value.trim() }); }
            }
            return definedResponses;
        }

        function generateAndInitialize() {
            definedFactors = getFactorsFromUI();
            currentDesignType = designTypeEl.value;
            if (definedFactors.length === 0) { customAlert('Please define at least one varying factor (Min ≠ Max).'); return; }
            if (['box-behnken', 'central-composite', 'fractional-factorial'].includes(currentDesignType) && definedFactors.length < 3) { customAlert("This design requires at least 3 varying factors."); return; }
            
            responses = getResponsesFromUI();
            if (responses.length === 0) { customAlert("Please define at least one response name."); return; }

            let experimentPlan;
            switch(currentDesignType) {
                case 'factorial': experimentPlan = generateFactorial(definedFactors); break;
                case 'fractional-factorial': experimentPlan = generateFractionalFactorial(definedFactors); break;
                case 'taguchi': experimentPlan = generateTaguchiL8(definedFactors); break;
                case 'box-behnken': experimentPlan = generateBoxBehnken(definedFactors); break;
                case 'central-composite': experimentPlan = generateCentralComposite(definedFactors); break;
            }

            if (!experimentPlan) return;
            
            experimentData = experimentPlan.map((settings, index) => {
                const exp = { id: index + 1, settings, score: null, weightedResponse: null };
                responses.forEach(r => { exp[r.id] = null; });
                return exp;
            });
            
            designSection.classList.add('hidden');
            resultsSection.classList.remove('hidden');
            renderAnalysisUI();
            renderTable();
            analyzeData();
        }
        
        // --- Design Generation Functions ---
        function generateFactorial(factors){const k=factors.length,numRuns=2**k,plan=[];for(let i=0;i<numRuns;i++){const settings={};for(let j=0;j<k;j++)settings[factors[j].name]=((i>>j)&1)===0?factors[j].min:factors[j].max;plan.push(settings)}return plan}
        function generateBoxBehnken(factors){const k=factors.length;if(k<3)return null;const plan=[],centerPoint={};factors.forEach(f=>centerPoint[f.name]=(f.min+f.max)/2);for(let i=0;i<k;i++)for(let j=i+1;j<k;j++)[-1,1].forEach(li=>[-1,1].forEach(lj=>{const settings={...centerPoint};settings[factors[i].name]=li===-1?factors[i].min:factors[i].max;settings[factors[j].name]=lj===-1?factors[j].min:factors[j].max;plan.push(settings)}));for(let i=0;i<Math.max(3,Math.floor(k/2)+1);i++)plan.push(centerPoint);return plan}
        function generateCentralComposite(factors){let plan=generateFactorial(factors);const k=factors.length;const centerPoint={};factors.forEach(f=>centerPoint[f.name]=(f.min+f.max)/2);for(let i=0;i<Math.max(3,k);i++)plan.push(centerPoint);const alpha=ccdTypeEl.value==='rotatable'?k**0.25:1;factors.forEach(f=>{plan.push({...centerPoint,[f.name]:uncodeValue(-alpha,f.min,f.max)});plan.push({...centerPoint,[f.name]:uncodeValue(alpha,f.min,f.max)})});return plan}
        
        function generateFractionalFactorial(factors) {
            const k = factors.length;
            let base_k, numRuns;
            if (k <= 4) { base_k = 3; numRuns = 8; } 
            else if (k <= 7) { base_k = 4; numRuns = 16; } 
            else { customAlert("Fractional Factorial designs for more than 7 factors are not implemented in this version."); return null; }
            
            const baseDesign = [];
            for (let i = 0; i < 2**base_k; i++) {
                const run = [];
                for (let j = 0; j < base_k; j++) { run.push(((i >> j) & 1) === 0 ? -1 : 1); }
                baseDesign.push(run);
            }

            const generators = {
                4: [[0, 1]], // D = AB
                5: [[0, 1], [0, 2]], // D = AB, E = AC
                6: [[0, 1], [0, 2], [1, 2]], // D = AB, E = AC, F = BC
                7: [[0, 1], [0, 2], [1, 2], [0, 1, 2]] // D=AB, E=AC, F=BC, G=ABC
            };
            
            const fullDesign = baseDesign.map(run => {
                const newRun = [...run];
                if (k > base_k) {
                    const gens = generators[k];
                    for(let i = 0; i < k - base_k; i++) {
                        let product = 1;
                        gens[i].forEach(idx => product *= run[idx]);
                        newRun.push(product);
                    }
                }
                return newRun;
            });

            const plan = fullDesign.map(codedRun => {
                const settings = {};
                factors.forEach((f, i) => {
                    settings[f.name] = codedRun[i] === -1 ? f.min : f.max;
                });
                return settings;
            });
            return plan;
        }

        function generateTaguchiL8(factors) {
            const k = factors.length;
            if (k > 7) { customAlert("The L8 array only supports up to 7 factors."); return null; }
            if (k < 2) { customAlert("Taguchi designs require at least 2 factors."); return null; }
            
            const L8_array = [
                [-1, -1, -1, -1, -1, -1, -1],
                [-1, -1, -1,  1,  1,  1,  1],
                [-1,  1,  1, -1, -1,  1,  1],
                [-1,  1,  1,  1,  1, -1, -1],
                [ 1, -1,  1, -1,  1, -1,  1],
                [ 1, -1,  1,  1, -1,  1, -1],
                [ 1,  1, -1, -1,  1,  1, -1],
                [ 1,  1, -1,  1, -1, -1,  1]
            ];
            
            const plan = L8_array.map(codedRun => {
                const settings = {};
                for (let i = 0; i < k; i++) {
                    settings[factors[i].name] = codedRun[i] === -1 ? factors[i].min : factors[i].max;
                }
                return settings;
            });
            return plan;
        }


        function fillWithTestData() {
            if (experimentData.length === 0 || responses.length === 0) { customAlert("Please generate a plan first."); return; }
            const modelCoeffs = [
                { intercept: 50, x1: 20, x2: -15, x3: 10, x1x1: -8, x2x2: -12, x1x2: 5 },
                { intercept: 100, x1: -10, x2: 25, x3: 5, x1x1: -15, x2x2: -5, x1x2: -10 },
                { intercept: 20, x1: 5, x2: 8, x3: -12, x1x1: -3, x2x2: -5, x1x2: 7 }
            ];
            experimentData.forEach(exp => {
                const x = definedFactors.map(f => codeValue(exp.settings[f.name], f.min, f.max));
                responses.forEach((response, i) => {
                    const coeffs = modelCoeffs[i];
                    let modelValue = coeffs.intercept + 
                                     (coeffs.x1 * (x[0]||0)) + (coeffs.x2 * (x[1]||0)) + (coeffs.x3 * (x[2]||0)) + 
                                     (coeffs.x1x1 * (x[0]||0)**2) + (coeffs.x2x2 * (x[1]||0)**2) + (coeffs.x1x2 * (x[0]||0) * (x[1]||0));
                    const noise = (Math.random() - 0.5) * (coeffs.intercept * 0.2);
                    let finalValue = Math.max(0, modelValue + noise);
                    exp[response.id] = finalValue;
                    const row = tableBody.querySelector(`tr[data-index="${exp.id - 1}"]`);
                    if (row) {
                        const input = row.querySelector(`input[data-metric="${response.id}"]`);
                        if (input) input.value = finalValue.toFixed(2);
                    }
                });
            });
            analyzeData();
        }

        function renderAnalysisUI() {
            optimalitySlidersContainer.innerHTML = '';
            optimumResultsContainer.innerHTML = '';
            predictedOptimaContainer.innerHTML = '';
            const colors = ['green', 'blue', 'yellow'];
            responses.forEach((r, i) => {
                const sliderDiv = document.createElement('div');
                sliderDiv.innerHTML = `<label for="${r.id}-weight" class="block text-sm font-medium text-slate-700">${r.name} Importance: <span id="${r.id}-weight-label" class="font-bold"></span></label><input id="${r.id}-weight" data-response-id="${r.id}" type="range" min="0" max="100" value="${Math.round(100/responses.length)}" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">`;
                optimalitySlidersContainer.appendChild(sliderDiv);
                const optimumDiv = document.createElement('div');
                optimumDiv.className = `p-4 bg-${colors[i]}-50 border border-${colors[i]}-200 rounded-lg`;
                optimumDiv.innerHTML = `<h3 class="font-semibold text-${colors[i]}-800">Highest ${r.name}</h3><p id="best-${r.id}" class="text-2xl font-bold text-${colors[i]}-600 mt-1">-</p><span class="text-sm text-slate-500" id="best-${r.id}-exp"></span>`;
                optimumResultsContainer.appendChild(optimumDiv);
                const predictedDiv = document.createElement('div');
                predictedDiv.id = `predicted-${r.id}-display`;
                predictedDiv.className = `hidden p-4 bg-${colors[i]}-50 border border-${colors[i]}-200 rounded-lg`;
                predictedOptimaContainer.appendChild(predictedDiv);
            });
            const bestOverallDiv = document.createElement('div');
            bestOverallDiv.className = 'p-4 bg-purple-50 border border-purple-200 rounded-lg';
            bestOverallDiv.innerHTML = `<h3 class="font-semibold text-purple-800">Best Weighted Score</h3><p id="best-overall" class="text-2xl font-bold text-purple-600 mt-1">-</p><span class="text-sm text-slate-500" id="best-overall-exp"></span>`;
            optimumResultsContainer.appendChild(bestOverallDiv);
            handleSliderChange();
        }

        function renderTable() {
            tableHead.innerHTML = '';
            tableBody.innerHTML = '';
            const headerRow = document.createElement('tr');
            const factorHeaders = definedFactors.map(f => `<th scope="col" class="px-6 py-3">${f.name}</th>`).join('');
            const responseHeaders = responses.map(r => `<th scope="col" class="px-6 py-3">${r.name}</th>`).join('');
            headerRow.innerHTML = `<th scope="col" class="px-6 py-3">Exp #</th>${factorHeaders}${responseHeaders}<th scope="col" class="px-6 py-3">Weighted Score</th>`;
            tableHead.appendChild(headerRow);
            experimentData.forEach((exp, index) => {
                const row = document.createElement('tr');
                row.className = 'bg-white border-b hover:bg-slate-50';
                row.dataset.index = index;
                const settingsHtml = definedFactors.map(f => `<td class="px-6 py-4 font-value"><input type="number" data-metric="setting" data-factor="${f.name}" value="${exp.settings[f.name].toFixed(3)}" class="w-24 bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2 text-center" min="0" step="any"></td>`).join('');
                const responsesHtml = responses.map(r => `<td class="px-6 py-4"><input type="number" data-metric="${r.id}" class="w-24 bg-slate-50 border-slate-300 text-slate-900 text-sm rounded-lg p-2" min="0" step="any"></td>`).join('');
                row.innerHTML = `<th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">${exp.id}</th>${settingsHtml}${responsesHtml}<td class="px-6 py-4 font-medium text-slate-600 score-cell">-</td>`;
                tableBody.appendChild(row)
            });
        }

        function handleTableInputChange(e) {
            if (e.target.matches('input[type="number"]')) {
                const rowIndex = e.target.closest('tr').dataset.index;
                const metric = e.target.dataset.metric;
                let value = e.target.value === '' || e.target.value === null ? null : parseFloat(e.target.value);
                if (value < 0) { value = 0; e.target.value = 0; }
                if (rowIndex < experimentData.length) {
                    if (metric === 'setting') {
                        experimentData[rowIndex].settings[e.target.dataset.factor] = value;
                    } else {
                        experimentData[rowIndex][metric] = value;
                    }
                    analyzeData();
                }
            }
        }

        function handleSliderChange() {
            const sliders = [...optimalitySlidersContainer.querySelectorAll('input[type="range"]')];
            let total = sliders.reduce((sum, s) => sum + parseFloat(s.value), 0);
            sliders.forEach(s => {
                const responseId = s.dataset.responseId;
                const label = document.getElementById(`${responseId}-weight-label`);
                if (label) {
                    const percentage = total === 0 ? Math.round(100 / sliders.length) : (s.value / total) * 100;
                    label.textContent = `${Math.round(percentage)}%`;
                }
            });
            analyzeData();
        }

        function analyzeData() {
            if (experimentData.length === 0 || responses.length === 0) return;
            let bests = {};
            responses.forEach(r => { bests[r.id] = { value: -Infinity, exp: null }; });
            let bestOverall = { value: -Infinity, exp: null };
            const valueRanges = {};
            responses.forEach(r => {
                const values = experimentData.map(e => e[r.id]).filter(v => v !== null && isFinite(v));
                valueRanges[r.id] = (values.length > 0) ? { min: Math.min(...values), max: Math.max(...values) } : { min: 0, max: 1 };
            });
            const normalize = (value, responseId) => {
                const { min, max } = valueRanges[responseId];
                return (max === min || value === null) ? 0 : (value - min) / (max - min);
            };
            const weights = {};
            let totalWeight = 0;
            responses.forEach(r => {
                const slider = document.getElementById(`${r.id}-weight`);
                weights[r.id] = slider ? parseFloat(slider.value) : 0;
                totalWeight += weights[r.id];
            });
            experimentData.forEach((exp, index) => {
                responses.forEach(r => {
                    if (exp[r.id] !== null && isFinite(exp[r.id]) && exp[r.id] > bests[r.id].value) {
                        bests[r.id] = { value: exp[r.id], exp: exp };
                    }
                });
                let scoreValue = 0, weightSumForScore = 0;
                if (totalWeight > 0) {
                    responses.forEach(r => {
                        if (exp[r.id] !== null && isFinite(exp[r.id])) {
                            scoreValue += (weights[r.id] / totalWeight) * normalize(exp[r.id], r.id);
                            weightSumForScore += (weights[r.id] / totalWeight);
                        }
                    });
                }
                exp.score = (weightSumForScore > 0) ? (scoreValue / weightSumForScore) : null;
                exp.weightedResponse = (responses.every(r => exp[r.id] !== null)) ? exp.score : null;
                if (exp.score !== null && exp.score > bestOverall.value) {
                    bestOverall = { value: exp.score, exp: exp };
                }
                const scoreCell = tableBody.querySelector(`tr[data-index="${index}"] .score-cell`);
                if (scoreCell) scoreCell.textContent = exp.score !== null ? exp.score.toFixed(3) : '-';
            });
            responses.forEach(r => {
                displayOptimum(document.getElementById(`best-${r.id}`), document.getElementById(`best-${r.id}-exp`), bests[r.id]);
            });
            displayOptimum(document.getElementById('best-overall'), document.getElementById('best-overall-exp'), bestOverall, '', 3);
            updateAdvancedVisualizations();
        }

        function displayOptimum(valueEl, expEl, result, unit = '', precision = 2) {
            if (result.exp) {
                valueEl.textContent = `${result.value.toFixed(precision)}${unit}`;
                expEl.textContent = `(Exp #${result.exp.id})`;
            } else {
                valueEl.textContent = '-';
                expEl.textContent = '';
            }
        }

        function updateAdvancedVisualizations() {
            [predictedOptimaCard, predictedCombinedDisplay, statisticsContainer, plotsCard, savePdfCard].forEach(el => el.classList.add('hidden'));
            statisticsContainer.innerHTML = '';
            contourPlotsContainer.innerHTML = '';
            if (!experimentData.some(exp => responses.some(r => exp[r.id] !== null))) return;
            const models = {};
            responses.forEach(r => { models[r.id] = buildModel(experimentData, definedFactors, r.id, currentDesignType); });
            const combinedStatsModel = buildModel(experimentData, definedFactors, 'weightedResponse', currentDesignType);
            const optima = {};
            responses.forEach(r => { optima[r.id] = models[r.id] ? findGlobalOptimum(models[r.id], definedFactors) : null; });
            const combinedOptimum = findCombinedOptimum(models, definedFactors);
            if (Object.values(models).some(m => m !== null)) {
                predictedOptimaCard.classList.remove('hidden');
                savePdfCard.classList.remove('hidden');
                statisticsContainer.classList.remove('hidden');
            }
            const colors = ['green', 'blue', 'yellow'];
            responses.forEach((r, i) => {
                buildOptimumDisplay(models[r.id], r.name, document.getElementById(`predicted-${r.id}-display`), colors[i], optima[r.id]);
            });
            buildCombinedOptimumDisplay(combinedOptimum, predictedCombinedDisplay, models);
            buildStatisticsDisplay(combinedStatsModel, 'Weighted Score Model');
            if (Object.values(models).some(m => m !== null) && definedFactors.length >= 2) {
                plotsCard.classList.remove('hidden');
                contourPlotsPlaceholder.style.display = 'none';
                buildContourPlots(definedFactors, models, optima);
            } else if (definedFactors.length < 2) {
                 contourPlotsPlaceholder.textContent = "2D plots require at least 2 varying factors.";
                 plotsCard.classList.remove('hidden');
                 contourPlotsPlaceholder.style.display = 'block';
            }
        }

        function buildCombinedOptimumDisplay(combinedOptimum, displayEl, models) {
            if (!combinedOptimum) { displayEl.classList.add('hidden'); return; }
            displayEl.classList.remove('hidden');
            let settingsHtml = Object.entries(combinedOptimum.settings).map(([key, value]) => `<li class="list-disc list-inside">${key}: <span class="font-value">${value.toFixed(3)}</span></li>`).join('');
            const getPIHtml = (model, codedSettings) => {
                if (!model) return '';
                const pi = getPredictionInterval(model, codedSettings);
                return `<span class="text-slate-500 text-xs"> (95% PI: ${pi.lower.toFixed(1)} - ${pi.upper.toFixed(1)})</span>`;
            };
            const colors = ['green', 'blue', 'yellow'];
            let predictionsHtml = responses.map((r, i) => `<p><span class="font-semibold text-${colors[i]}-700">${r.name}:</span> <strong class="font-value text-${colors[i]}-700">${combinedOptimum.predictions[r.id].toFixed(2)}</strong>${getPIHtml(models[r.id], combinedOptimum.codedSettings)}</p>`).join('');
            displayEl.innerHTML = `<h3 class="font-semibold text-purple-800 mb-2">Combined Optimum (Predicted)</h3><p>Weights-based, best compromise:</p><ul class="mt-1 mb-2">${settingsHtml}</ul><p>With these parameters, the predicted results are:</p><div class="mt-1 text-sm grid grid-cols-1 md:grid-cols-3 gap-2">${predictionsHtml}</div>`;
        }

        function buildOptimumDisplay(model, responseName, displayEl, color, optimumResult) {
            if (!model || !optimumResult) { displayEl.classList.add('hidden'); return; }
            displayEl.classList.remove('hidden');
            const { optimum } = optimumResult;
            let paramsHtml = Object.entries(optimum.settings).map(([key, value]) => `<li class="list-disc list-inside">${key}: <span class="font-value">${value.toFixed(3)}</span></li>`).join('');
            displayEl.innerHTML = `<h3 class="font-semibold text-${color}-800 mb-2">Mathematical Optimum (${responseName})</h3><p>Max. predicted ${responseName}: <strong class="text-${color}-600 font-value">${optimum.z.toFixed(2)}</strong> at:</p><ul class="mt-1 text-sm">${paramsHtml}</ul>`;
            const responseId = responses.find(r => r.name === responseName)?.id;
            if (!responseId) return;
            const measuredValues = experimentData.map(e => e[responseId]).filter(v => v !== null);
            if (measuredValues.length > 0) {
                const measuredMax = Math.max(...measuredValues);
                if (measuredMax > optimum.z) {
                    const noteP = document.createElement('p');
                    noteP.className = 'text-xs text-slate-500 mt-2 italic';
                    noteP.innerHTML = `Note: The highest measured value of <strong class="font-value">${measuredMax.toFixed(2)}</strong> exceeds this prediction.`;
                    displayEl.appendChild(noteP);
                }
            }
        }

        function findCombinedOptimum(models, varyingFactors) {
             if (responses.some(r => !models[r.id])) return null;
             const ranges = {};
             responses.forEach(r => {
                const allValues = experimentData.map(e => e[r.id]).filter(v => v !== null && isFinite(v));
                ranges[r.id] = { min: allValues.length > 0 ? Math.min(...allValues) : 0, max: allValues.length > 0 ? Math.max(...allValues) : 1, };
                if(ranges[r.id].min === ranges[r.id].max) ranges[r.id].max += 1;
             });
             const normalizePred = (val, responseId) => (val - ranges[responseId].min) / (ranges[responseId].max - ranges[responseId].min);
             const weights = {};
             let totalWeight = 0;
             responses.forEach(r => {
                const slider = document.getElementById(`${r.id}-weight`);
                weights[r.id] = slider ? parseFloat(slider.value) : 0;
                totalWeight += weights[r.id];
             });
             if (totalWeight === 0) return null;
             const predictCombined = (codedSettings) => {
                let combinedScore = 0;
                responses.forEach(r => {
                    const predValue = predictFromModel(models[r.id], codedSettings);
                    combinedScore += (weights[r.id] * normalizePred(predValue, r.id));
                });
                return combinedScore / totalWeight;
             };
             const codedBounds = {};
             varyingFactors.forEach(f => { codedBounds[f.name] = { min: -1, max: 1 } });
             let bestCoded = findOptimumRandomWalk(predictCombined, codedBounds, varyingFactors);
             let bestRealSettings = {};
             varyingFactors.forEach(f => {
                 if (bestCoded.settings[f.name] !== undefined) {
                     bestRealSettings[f.name] = uncodeValue(bestCoded.settings[f.name], f.min, f.max);
                 }
             });
             const predictionsAtOpt = {};
             responses.forEach(r => { predictionsAtOpt[r.id] = Math.max(0, predictFromModel(models[r.id], bestCoded.settings)); });
             return { settings: bestRealSettings, codedSettings: bestCoded.settings, predictions: predictionsAtOpt };
         }

        function buildStatisticsDisplay(model, responseName) {
            if (!model) return;
            const card = document.createElement('div');
            card.className = 'card';
            const statsOrder = ['Std. Dev.', 'Mean', 'C.V. %', 'PRESS', 'R-Squared', 'Adj R-Squared', 'Pred R-Squared', 'Adeq. Precision'];
            const fitStatsHtml = statsOrder.map(key => `<tr><td class="py-1 pr-4 font-medium text-slate-600">${key}</td><td class="py-1 text-right font-value">${model.stats[key]?.toFixed(4) ?? '-'}</td></tr>`).join('');
            card.innerHTML = `<h2 class="text-2xl font-semibold text-slate-700 mb-4">${responseName} Statistics</h2><p class="text-xs text-slate-500 mb-4 -mt-2">Model coefficients are based on coded units [-1, 1].</p><div class="grid grid-cols-1"><div class="overflow-x-auto"><table class="w-full text-sm coefficients-table"><thead><tr class="border-b"><th class="px-2 py-1 text-left">Term</th><th class="px-2 py-1 text-right">Coefficient</th><th class="px-2 py-1 text-right">Std. Error</th><th class="px-2 py-1 text-right">95% CI Lower</th><th class="px-2 py-1 text-right">95% CI Upper</th></tr></thead><tbody>${Object.entries(model.coeffs).map(([term, stats])=>`<tr><td class="border-t px-2 py-1">${term.replace(/\*/g, ' * ')}</td><td class="border-t px-2 py-1 text-right font-value">${stats.value.toFixed(4)}</td><td class="border-t px-2 py-1 text-right font-value">${stats.stdError.toFixed(4)}</td><td class="border-t px-2 py-1 text-right font-value">${stats.ciLower.toFixed(4)}</td><td class="border-t px-2 py-1 text-right font-value">${stats.ciUpper.toFixed(4)}</td></tr>`).join('')}</tbody></table></div><p class="text-xs text-slate-500 mt-2">* Confidence intervals are approximated using a t-value of 1.96.</p></div><div class="border-t pt-4 mt-4"><table class="w-full text-sm fit-statistics-table"><tbody>${fitStatsHtml}</tbody></table></div></div>`;
            statisticsContainer.appendChild(card);
        }

        function buildContourPlots(varyingFactors, models, optima) {
            contourPlotsContainer.innerHTML = '';
            const factorPairs = [];
            for (let i = 0; i < varyingFactors.length; i++) for (let j = i + 1; j < varyingFactors.length; j++) factorPairs.push([varyingFactors[i], varyingFactors[j]]);
            factorPairs.forEach(([factorX, factorY], pairIndex) => {
                const pairWrapper = document.createElement('div');
                pairWrapper.className = 'space-y-4 border-t pt-6 mt-6';
                if(pairIndex === 0) pairWrapper.classList.remove('border-t', 'pt-6', 'mt-6');
                const title = document.createElement('h3');
                title.className = "text-xl font-semibold text-center text-slate-700";
                title.textContent = `${factorX.name} vs ${factorY.name}`;
                pairWrapper.appendChild(title);
                const plotsDiv = document.createElement('div');
                plotsDiv.className = 'grid grid-cols-1 md:grid-cols-3 gap-8';
                responses.forEach((response) => {
                    const model = models[response.id];
                    const optimumResult = optima[response.id];
                    if (model && optimumResult) {
                        const plotDiv = document.createElement('div');
                        const canvasId = `contour-${response.id}-${pairIndex}`;
                        plotDiv.innerHTML = `<h4 class="font-medium text-center text-slate-600 mb-2">${response.name}</h4><canvas id="${canvasId}" class="w-full h-auto"></canvas>`;
                        plotsDiv.appendChild(plotDiv);
                        setTimeout(() => draw2DContourPlot(canvasId, model, factorX, factorY, optimumResult), 0);
                    }
                });
                if (plotsDiv.children.length > 0) pairWrapper.appendChild(plotsDiv);
                contourPlotsContainer.appendChild(pairWrapper);
            });
        }

        function draw2DContourPlot(canvasId, model, factorX, factorY, optimumResult) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = 400, height = 350;
            canvas.width = width; canvas.height = height;
            const margin = { top: 30, right: 70, bottom: 50, left: 60 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, width, height);
            const otherFactors = definedFactors.filter(f => f.name !== factorX.name && f.name !== factorY.name);
            const fixedValues = {};
            otherFactors.forEach(f => { fixedValues[f.name] = (f.min + f.max) / 2; });
            const predict = (realSettings) => {
                let codedSettings = {};
                definedFactors.forEach(f => {
                    const valueToCode = realSettings[f.name] ?? (f.min + f.max) / 2;
                    codedSettings[f.name] = codeValue(valueToCode, f.min, f.max);
                });
                return predictFromModel(model, codedSettings);
            };
            const imageData = ctx.createImageData(plotWidth, plotHeight);
            let minZ = Infinity, maxZ = -Infinity;
            const zValues = [];
            for (let j = 0; j < plotHeight; j++) {
                for (let i = 0; i < plotWidth; i++) {
                    let currentSettings = { ...fixedValues };
                    currentSettings[factorX.name] = factorX.min + (i / (plotWidth - 1)) * (factorX.max - factorX.min);
                    currentSettings[factorY.name] = factorY.min + ((plotHeight - 1 - j) / (plotHeight - 1)) * (factorY.max - factorY.min);
                    const z = predict(currentSettings);
                    zValues.push(z);
                    if (isFinite(z)) { if (z < minZ) minZ = z; if (z > maxZ) maxZ = z; }
                }
            }
            for (let i = 0; i < zValues.length; i++) {
                const z = zValues[i];
                const zRange = maxZ - minZ;
                const normZ = isFinite(z) ? Math.max(0, Math.min(1, (z - minZ) / (zRange || 1))) : 0;
                const color = new THREE.Color();
                color.setHSL((240 - (normZ * 240)) / 360, 0.9, 0.5);
                const pIdx = i * 4;
                imageData.data[pIdx] = color.r * 255; imageData.data[pIdx + 1] = color.g * 255; imageData.data[pIdx + 2] = color.b * 255; imageData.data[pIdx + 3] = 255;
            }
            ctx.putImageData(imageData, margin.left, margin.top);
            ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.font = '11px Inter'; ctx.fillStyle = '#333'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.beginPath(); ctx.moveTo(margin.left, margin.top + plotHeight); ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight); ctx.stroke();
            for (let i = 0; i < 5; i++) {
                const val = factorX.min + (i / 4) * (factorX.max - factorX.min);
                const x = margin.left + (i / 4) * plotWidth;
                ctx.beginPath(); ctx.moveTo(x, margin.top + plotHeight); ctx.lineTo(x, margin.top + plotHeight + 5); ctx.stroke();
                ctx.fillText(val.toFixed(1), x, margin.top + plotHeight + 15);
            }
            ctx.fillText(factorX.name, margin.left + plotWidth / 2, margin.top + plotHeight + 35);
            ctx.beginPath(); ctx.moveTo(margin.left, margin.top); ctx.lineTo(margin.left, margin.top + plotHeight); ctx.stroke();
            for (let i = 0; i < 5; i++) {
                const val = factorY.min + (i / 4) * (factorY.max - factorY.min);
                const y = margin.top + plotHeight - (i / 4) * plotHeight;
                ctx.beginPath(); ctx.moveTo(margin.left, y); ctx.lineTo(margin.left - 5, y); ctx.stroke();
                ctx.textAlign = 'right'; ctx.fillText(val.toFixed(1), margin.left - 10, y);
            }
            ctx.save(); ctx.translate(margin.left - 45, margin.top + plotHeight / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText(factorY.name, 0, 0); ctx.restore();
            const legendWidth = 15, legendX = width - margin.right + 15;
            const legendGradient = ctx.createLinearGradient(0, margin.top + plotHeight, 0, margin.top);
            for (let i = 0; i <= 1; i += 0.1) {
                const color = new THREE.Color();
                color.setHSL((240 - (i * 240)) / 360, 0.9, 0.5);
                legendGradient.addColorStop(i, `rgb(${color.r*255}, ${color.g*255}, ${color.b*255})`);
            }
            ctx.fillStyle = legendGradient; ctx.fillRect(legendX, margin.top, legendWidth, plotHeight); ctx.strokeStyle = '#333'; ctx.strokeRect(legendX, margin.top, legendWidth, plotHeight);
            ctx.fillStyle = '#333'; ctx.textAlign = 'left'; ctx.font = '10px Inter';
            ctx.fillText(maxZ.toFixed(1), legendX + legendWidth + 5, margin.top); ctx.fillText(minZ.toFixed(1), legendX + legendWidth + 5, margin.top + plotHeight);
            const optimumSettings = optimumResult.optimum.settings;
            if (optimumSettings[factorX.name] !== undefined && optimumSettings[factorY.name] !== undefined) {
                const optX = margin.left + ((optimumSettings[factorX.name] - factorX.min) / (factorX.max - factorX.min)) * plotWidth;
                const optY = margin.top + plotHeight - (((optimumSettings[factorY.name] - factorY.min) / (factorY.max - factorY.min)) * plotHeight);
                if (isFinite(optX) && isFinite(optY)) {
                    ctx.font = '24px sans-serif'; ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.strokeText('★', optX, optY); ctx.fillText('★', optX, optY);
                }
            }
        }

        const matrix={multiply:(a,b)=>{if(!a||!b||a.length===0||b.length===0||a[0].length!==b.length)return null;return a.map((r,i)=>b[0].map((_,j)=>r.reduce((s,e,k)=>s+(e*b[k][j]),0)))},transpose:a=>a[0].map((_,i)=>a.map(r=>r[i])),invert:m=>{const n=m.length,id=m.map((_,i)=>m.map((_,j)=>i===j?1:0)),C=m.map((r,i)=>[...r,...id[i]]);for(let i=0;i<n;i++){let p=i;while(p<n&&C[p][i]===0)p++;if(p===n)return null;[C[i],C[p]]=[C[p],C[i]];let d=C[i][i];for(let j=i;j<2*n;j++)C[i][j]/=d;for(let k=0;k<n;k++)if(k!==i){let mu=C[k][i];for(let j=i;j<2*n;j++)C[k][j]-=mu*C[i][j]}}return C.map(r=>r.slice(n))},dot:(v1,v2)=>v1.reduce((s,x,i)=>s+x*v2[i],0),norm:v=>Math.sqrt(v.reduce((s,x)=>s+x*x,0))};
        const codeValue=(realValue,min,max)=>(max===min)?0:(2*(realValue-min)/(max-min)-1);
        const uncodeValue=(codedValue,min,max)=>min+(codedValue+1)*(max-min)/2;

        function buildModel(dataPoints,factors,responseId,designType){const validData=dataPoints.filter(d=>d[responseId]!==null&&isFinite(d[responseId])&&factors.every(f=>d.settings[f.name]!==undefined));const k=factors.length;let termHeaders=['Intercept'];factors.forEach(f=>termHeaders.push(f.name));const isScreening=['taguchi','fractional-factorial'].includes(designType);if(!isScreening){if(designType!=='factorial'){for(let i=0;i<k;i++){termHeaders.push(`${factors[i].name}*${factors[i].name}`);for(let j=i+1;j<k;j++){termHeaders.push(`${factors[i].name}*${factors[j].name}`)}}}else{for(let i=0;i<k;i++)for(let j=i+1;j<k;j++)termHeaders.push(`${factors[i].name}*${factors[j].name}`)}}if(validData.length<termHeaders.length)return null;const X=validData.map(p=>{const codedSettings={};factors.forEach(f=>codedSettings[f.name]=codeValue(p.settings[f.name],f.min,f.max));const row=[1];factors.forEach(f=>row.push(codedSettings[f.name]));if(!isScreening){if(designType!=='factorial'){for(let i=0;i<k;i++){row.push(codedSettings[factors[i].name]**2);for(let j=i+1;j<k;j++){row.push(codedSettings[factors[i].name]*codedSettings[factors[j].name])}}}else{for(let i=0;i<k;i++)for(let j=i+1;j<k;j++)row.push(codedSettings[factors[i].name]*codedSettings[factors[j].name])}}return row});let yObserved=validData.map(p=>p[responseId]);const Xt=matrix.transpose(X),XtX=matrix.multiply(Xt,X),XtX_inv=matrix.invert(XtX);if(!XtX_inv)return null;const b=matrix.multiply(XtX_inv,matrix.multiply(Xt,yObserved.map(v=>[v]))).map(c=>c[0]);const yPredicted=matrix.multiply(X,b.map(c=>[c])).map(v=>v[0]);const yMean=yObserved.reduce((a,b)=>a+b,0)/yObserved.length;const residuals=yObserved.map((y,i)=>y-yPredicted[i]);const ssError=residuals.reduce((sum,r)=>sum+r*r,0);const ssTotal=yObserved.reduce((sum,y)=>sum+(y-yMean)**2,0);const n=validData.length,p_terms=b.length;if(n-p_terms<=0)return null;const msError=ssError/(n-p_terms);const hatDiag=X.map(x_i=>matrix.dot(matrix.multiply([x_i],XtX_inv)[0],x_i));const press=residuals.reduce((sum,r,i)=>(1-hatDiag[i]>1e-9)?sum+Math.pow(r/(1-hatDiag[i]),2):sum,0);const predR2=ssTotal>0?1-(press/ssTotal):1;const stdDev=Math.sqrt(msError);const cv=yMean!==0?Math.abs((stdDev/yMean)*100):0;const yPredRange=Math.max(...yPredicted)-Math.min(...yPredicted);const adeqPrec=msError>0?yPredRange/Math.sqrt(p_terms*msError/n):Infinity;const r2=ssTotal>0?1-(ssError/ssTotal):1;const adjR2=n-p_terms-1>0?1-((1-r2)*(n-1))/(n-p_terms-1):r2;const t_critical=1.96;const coeffsWithStats={};termHeaders.forEach((key,i)=>{const c_ii=XtX_inv[i][i];const stdError=Math.sqrt(msError*c_ii);const marginOfError=t_critical*stdError;coeffsWithStats[key]={value:b[i],stdError,ciLower:b[i]-marginOfError,ciUpper:b[i]+marginOfError}});return{coeffs:coeffsWithStats,stats:{'Std. Dev.':stdDev,Mean:yMean,'C.V. %':cv,PRESS:press,'R-Squared':r2,'Adj R-Squared':adjR2,'Pred R-Squared':predR2,'Adeq. Precision':adeqPrec,msError},matrixInfo:{XtX_inv,termHeaders}}}
        const predictFromModel=(model,codedSettings)=>{if(!model||!model.coeffs)return NaN;let y=model.coeffs['Intercept']?.value??0;for(const[term,coeff]of Object.entries(model.coeffs)){if(term==='Intercept')continue;const factorsInTerm=term.split('*').map(t=>t.trim());if(factorsInTerm.length===1){y+=coeff.value*(codedSettings[factorsInTerm[0]]??0)}else if(factorsInTerm.length===2){if(factorsInTerm[0]===factorsInTerm[1]){y+=coeff.value*(codedSettings[factorsInTerm[0]]??0)**2}else{y+=coeff.value*(codedSettings[factorsInTerm[0]]??0)*(codedSettings[factorsInTerm[1]]??0)}}}return isNaN(y)?-Infinity:y}
        function getPredictionInterval(model,codedSettings){const x0=[];model.matrixInfo.termHeaders.forEach(term=>{if(term==='Intercept'){x0.push(1)}else{const f=term.split('*').map(t=>t.trim());if(f.length===1){x0.push(codedSettings[f[0]]??0)}else if(f.length===2){if(f[0]===f[1]){x0.push((codedSettings[f[0]]??0)**2)}else{x0.push((codedSettings[f[0]]??0)*(codedSettings[f[1]]??0))}}}});const leverage=matrix.dot(matrix.multiply([x0],model.matrixInfo.XtX_inv)[0],x0);const se_pred=Math.sqrt(model.stats.msError*(1+leverage));const margin=1.96*se_pred;const prediction=predictFromModel(model,codedSettings);return{lower:prediction-margin,upper:prediction+margin}}
        function findGlobalOptimum(model, varyingFactors) {if(!model)return null;const predictCoded=cs=>predictFromModel(model,cs);const codedBounds={};varyingFactors.forEach(f=>{codedBounds[f.name]={min:-1,max:1}});let bestCoded=findOptimumRandomWalk(predictCoded,codedBounds,varyingFactors);let bestRealSettings={};varyingFactors.forEach(f=>{if(bestCoded.settings[f.name]!==undefined)bestRealSettings[f.name]=uncodeValue(bestCoded.settings[f.name],f.min,f.max)});let bestZ=Math.max(0,bestCoded.z);return{optimum:{z:bestZ,settings:bestRealSettings}}}
        function findOptimumRandomWalk(predict,bounds,varyingFactors){const precision=rwPrecisionEl.value;let initialPoints,maxIterations;switch(precision){case'coarse':initialPoints=200;maxIterations=800;break;case'extensive':initialPoints=2000;maxIterations=98000;break;default:initialPoints=1000;maxIterations=9000;break}let bestSettings={},bestZ=-Infinity;for(let i=0;i<initialPoints;i++){let currentSettings={};varyingFactors.forEach(f=>{currentSettings[f.name]=bounds[f.name].min+Math.random()*(bounds[f.name].max-bounds[f.name].min)});const z=predict(currentSettings);if(z>bestZ){bestZ=z;bestSettings=currentSettings}}for(let i=0;i<maxIterations;i++){let newSettings={};const decay=1-((i/maxIterations)**2);varyingFactors.forEach(f=>{const range=(bounds[f.name].max-bounds[f.name].min)*0.2*decay;newSettings[f.name]=(bestSettings[f.name]??0)+(Math.random()-0.5)*range;newSettings[f.name]=Math.max(bounds[f.name].min,Math.min(bounds[f.name].max,newSettings[f.name]))});const z=predict(newSettings);if(z>bestZ){bestZ=z;bestSettings=newSettings}}return{z:bestZ,settings:bestSettings}}

        function saveAsPDF() {
            customAlert('Generating PDF... Please wait.');
            setTimeout(() => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const now = new Date();
                const timestamp = now.toLocaleString();
                const filenameTimestamp = now.toISOString().replace(/:/g, '-').slice(0, 19);
                
                let yPos = 22;

                // --- PDF Header ---
                doc.setFontSize(18); doc.text('Experiment Analysis Report', 14, yPos); yPos += 6;
                doc.setFontSize(11); doc.text(`Generated on: ${timestamp}`, 14, yPos); yPos += 10;
                
                // --- Design Info ---
                //doc.setFontSize(12); doc.text('Design Information', 14, yPos); yPos += 6;
                //doc.setFontSize(10);
                let designText = `Design Type: ${designTypeEl.options[designTypeEl.selectedIndex].text}`;
                if (currentDesignType === 'central-composite') {
                    designText += ` (${ccdTypeEl.options[ccdTypeEl.selectedIndex].text})`;
                }
                doc.text(designText, 14, yPos); yPos += 15;
                doc.setDrawColor(220, 220, 220); doc.line(14, yPos - 5, 196, yPos - 5);

                // --- Section 1: Experiment Data Table ---
                doc.setFontSize(14); doc.text('Experiment Data Table', 14, yPos);
                const dataTableHead = [[...tableHead.querySelectorAll('th')].map(th => th.textContent)];
                const dataTableBody = Array.from(tableBody.querySelectorAll('tr')).map(row => {
                    const id = row.querySelector('th').textContent;
                    const settings = [...row.querySelectorAll('input[data-metric="setting"]')].map(input => input.value || '-');
                    const responseValues = [...row.querySelectorAll('input[data-metric^="response"]')].map(input => input.value || '-');
                    const score = row.querySelector('.score-cell').textContent;
                    return [id, ...settings, ...responseValues, score];
                });
                doc.autoTable({ head: dataTableHead, body: dataTableBody, startY: yPos + 4, headStyles: { fillColor: [79, 70, 229] }, styles: { fontSize: 6, cellPadding: 1.5 }});
                yPos = doc.lastAutoTable.finalY + 15;
                
                // --- Section 2: Predicted Optima ---
                if (!predictedOptimaCard.classList.contains('hidden')) {
                    if (yPos > 250) { doc.addPage(); yPos = 22; }
                    doc.setDrawColor(220, 220, 220); doc.line(14, yPos - 5, 196, yPos - 5); yPos += 10;
                    doc.setFontSize(14); doc.text('Predicted Optimum Conditions', 14, yPos); yPos += 8;
                    const addOptimumToPdf = (displayEl, yPosition, color) => {
                        if (!displayEl || displayEl.classList.contains('hidden')) return yPosition;
                        const title = displayEl.querySelector('h3').textContent;
                        const bodyItems = [];
                        displayEl.querySelectorAll('p, ul li, div > p').forEach(el => bodyItems.push([el.innerText.replace(/\s+/g, ' ')]));
                        doc.autoTable({ head: [[title]], body: bodyItems, startY: yPosition, theme: 'plain', headStyles: { fontStyle: 'bold', fillColor: color }, styles: { cellPadding: 1.5, fontSize: 9 } });
                        return doc.lastAutoTable.finalY + 4;
                    };
                    const colors = [[232, 245, 233], [227, 242, 253], [254, 252, 215]];
                    responses.forEach((r, i) => { yPos = addOptimumToPdf(document.getElementById(`predicted-${r.id}-display`), yPos, colors[i]); });
                    yPos = addOptimumToPdf(predictedCombinedDisplay, yPos, [237, 233, 251]);
                    yPos += 11;
                }

                // --- Section 3: Statistics ---
                document.querySelectorAll('#statistics-container .card').forEach((card, i) => {
                    if (yPos > 190) { doc.addPage(); yPos = 20; }
                    doc.setDrawColor(220, 220, 220); doc.line(14, yPos - 5, 196, yPos - 5); yPos += 10;
                    const title = card.querySelector('h2').textContent;
                    doc.setFontSize(14); doc.text(title, 14, yPos); yPos += 6;
                    card.querySelectorAll('p').forEach(p => { doc.setFontSize(8).text(p.innerText, 14, yPos); yPos += 4; });
                    doc.autoTable({ html: card.querySelector('.coefficients-table'), startY: yPos, theme: 'grid', styles: { cellPadding: 1, fontSize: 8 }});
                    yPos = doc.lastAutoTable.finalY + 4;
                    doc.autoTable({ html: card.querySelector('.fit-statistics-table'), startY: yPos, theme: 'plain', styles: { cellPadding: 1, fontSize: 8 }});
                    yPos = doc.lastAutoTable.finalY + 15;
                });

                // --- Section 4: Plots ---
                const allCanvases = document.querySelectorAll('#contour-plots-container canvas');
                if (allCanvases.length > 0) {
                     if (yPos > 30) { doc.addPage(); yPos = 20; }
                     doc.setDrawColor(220, 220, 220); doc.line(14, yPos - 5, 196, yPos - 5); yPos += 10;
                     doc.setFontSize(14); doc.text('2D Contour Plots', 14, yPos); yPos += 8;
                    document.querySelectorAll('#contour-plots-container > div').forEach((pairWrapper) => {
                        const pairTitle = pairWrapper.querySelector('h3');
                        if (pairTitle) {
                            if (yPos > 250) { doc.addPage(); yPos = 20; }
                            doc.setFontSize(12).text(pairTitle.textContent, 105, yPos, { align: 'center' });
                            yPos += 8;
                        }
                        const plotDivs = pairWrapper.querySelectorAll('.grid > div');
                        if (plotDivs.length === 0) return;
                        let plotWidthOnPdf = 180 / plotDivs.length - 5;
                        let rowHeight = 0;
                        plotDivs.forEach((plotDiv, plotIndex) => {
                             const canvas = plotDiv.querySelector('canvas');
                             const title = plotDiv.querySelector('h4');
                             if (!canvas || !title) return;
                             const imgData = canvas.toDataURL('image/png');
                             const imgHeight = canvas.height * (plotWidthOnPdf / canvas.width);
                             if(plotIndex === 0) rowHeight = imgHeight;
                             const xPos = 14 + (plotIndex * (plotWidthOnPdf + 5));
                             if (yPos + imgHeight + 20 > doc.internal.pageSize.height) { doc.addPage(); yPos = 20; }
                             doc.setFontSize(10).text(title.textContent, xPos + (plotWidthOnPdf / 2), yPos, { align: 'center' });
                             doc.addImage(imgData, 'PNG', xPos, yPos + 4, plotWidthOnPdf, imgHeight);
                        });
                        yPos += rowHeight + 15;
                    });
                }

                // --- PDF Footer ---
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    doc.text(`Page ${i} of ${pageCount}`, 105, doc.internal.pageSize.height - 10, { align: 'center' });
                }
                doc.setPage(pageCount);
                doc.text(footerLeft.textContent, 14, doc.internal.pageSize.height - 10);
                doc.text(footerRight.textContent, 205 - doc.getTextWidth(footerRight.textContent) - 14, doc.internal.pageSize.height - 10);

                doc.save(`doe_report_${filenameTimestamp}.pdf`);
                alertClose.click();
            }, 500);
        }

        window.onload = () => {
            setupFactorInputs();
            setupResponseInputs();
            handleDesignTypeChange();
        };
    </script>
</body>
</html>
